/*
 * Audio_Output_Avr.cpp
 *
 * Created: 15/05/2021 06:37:06
 * Author : Nuwan Udara
 */ 

#define F_CPU  1000000UL //problem with proteus simulation, so currently using 1MHz F_CPU //#define F_CPU  16000000UL
#include <avr/io.h>
#define __DELAY_BACKWARD_COMPATIBLE__    // This is requaired to make _delay_ms() take vairables
#include <util/delay.h>					// for delay functions
#include <avr/interrupt.h>			   // for clocks and interrupts 
#include <avr/pgmspace.h>			  //for PROGMEM 
#include "pitches.h"
#include "melodies.h"
 
//input pins
int playbutton=PORTB5;
int changenextsong=PORTB4;
int interruptPin = PORTD2;

// Square Wave generating methods
void feq_ctc(int step); // the CTC implementation *buggy
void Delay_note_method(float freq , float dur);// Using oscillator with CPU cycles delay. A raw method

//Output pins
int buzzer[3]={DDRB,PORTB,PORTB0};

//currently testing multiple methods to generate signals



//Local variables
int songnumber=1;


void changesong(){
	
	_delay_ms(500);
	if (songnumber==3){songnumber=0;}
	else{songnumber++;}
}

int main(void)
{
	// pins ports declaration
	buzzer[0] |= _BV(buzzer[2]) ;// make buzzer pin output
	
    /* Replace with your application code */
    while (1) 
    {
		
		
    }
}

/** The Interrupt function we use with CTC mode code

**/

ISR(TIMER1_COMPA_vect)          // 16 bit Timer interrupt handler
{
	PORTB ^= (1 << PORTB0); // generate square wave (toggle)
}


/**
Use 16bit timer to generate square pulses
You need to give the comparison bit which is used in CTC mode
Using 1024 prescaler so the we can produce all the frequancies we desire
Currently bit unstable
The built in clock pin is using here
**/


void feq_ctc(int step){                          // using built in 16bit timer with prescaler 1024 CTC mode.
	TCCR1B = (1 << WGM12); // enable CTC mode
	OCR1A =step;                              // step is the comparison step number
	TIMSK1 = (1 << OCIE1A);					  // set for CTC Mode
	
	sei();									// Call interrupt
	
	TCCR1B |= (1 << CS12) | (1 << CS10);     // Prescaler 1024
	//{Problem with pulse width and low frequancies not working well}
}

/**
Use delays and CPU cycles to generate square waves
Take frequency and the duration as inputs
get period in miliseconds by T=1/feqruancy *1000 ms
and Calculate how many times the signal has to repeat by cycles=Duration/Period
We will treat it as an integer. 
The 50% square wave is generated by 50% of the period time pin High (5V)
50% of the period_time Low (0V)

**/

void Delay_note_method(float freq,float dur){
	
	// variables
		long int i,cycles;     
		float half_period,period;
		
		if (freq != 0){
			period=(1/freq)*1000;
			cycles=dur/period;
			half_period = period/2;

			for (i=0;i<cycles;i++)
			{
				//50% duty cycle
				
				_delay_ms(half_period);
				
				buzzer[1] |= _BV(buzzer[2]);
				
				_delay_ms(half_period);
				
				buzzer[1] &= ~ _BV(buzzer[2]);
			}
		}
		else {
			_delay_ms(dur);   // rest
		}

		return;
		
		
}
